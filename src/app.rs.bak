#![allow(dead_code)]

use std::{cell::RefCell, char, io::{stdout, Write}, thread, time, usize};
use jsonreader::JsonSplitter;
use mocks::Mocks;
use ncurses::{self};
use parser::{Parser, ParseResult};

#[derive(Debug, Default)]
pub struct App {
    lines: Vec<String>,
    input: RefCell<Option<String>>,
    splitter: JsonSplitter,
}

impl App {

    pub fn add_lines(&mut self, lines: &mut Vec<String>) {
        self.lines.append(lines);
    }

    pub fn add_line(&mut self, line: String) {
        self.lines.push(line);
    }

    fn render_input(&mut self, y: i32) {
        ncurses::mv(y, 0);
        ncurses::clrtoeol();
        let a = self.input.clone().replace(None).unwrap_or(String::default());
        ncurses::mvaddstr(y, 0, format!("> {}", a).as_str()).unwrap();
    }

    fn get_visible_log_lines(&self, max: i32) -> impl Iterator<Item=&String> {
        let max = max as usize;
        let len = self.lines.len();
         
        if len <= max {
            return self.lines.iter();
        }

        return self.lines.as_slice()[len - max..].iter()
    }
    
    pub fn render(&mut self) {

        let mut max_y = 0;
        let mut max_x = 0;
        ncurses::getmaxyx(ncurses::stdscr(), &mut max_y, &mut max_x);

        for (i, line) in self.get_visible_log_lines(max_y - 1).enumerate() {
            ncurses::mvaddstr(i as i32, 0, line).unwrap();
        }

        self.render_input(max_y - 1)
    }

    pub fn update_input(&mut self, ch: i32) -> Option<String> {
        if Self::is_enter_key(ch) {
            return self.input.replace(None);
        } else if Self::is_backspace(ch) {
            if let Some(mut s) = self.input.replace(None) {
                if s.len() > 0 {
                    s.remove(s.len() - 1);
                    self.input.replace(Some(s));
                }
            }
            return None;
        }

        if let Some(ch) = ncurses_ch_to_char(ch) {
            let before = self.input.replace(None);
            let now = match before {
                Some(s) => s + ch.to_string().as_str(),
                _ => ch.to_string(),
            };
            self.input.replace(Some(now));
        }

        None
    }

    fn is_backspace(ch: i32) -> bool {
       ch == ncurses::KEY_BACKSPACE || ch == ncurses::KEY_DC
    }

    fn is_enter_key(ch: i32) -> bool {
        ch == ('\n' as i32) || ch == ('\r' as i32)
    }

    pub run(app: &mut App, adapter: &mut impl adapter::Adapter, mocks: Mocks) -> Option<> {
        loop {
            // check if there is user input
            let ch = ncurses::getch();
            if let Some(s) = app.update_input(ch) {
                let cmd = Parser::parse(s);
                match cmd {
                    ParseResult::List => {
                        match mocks.list() {
                            Ok(ps) => {
                                app.add_lines(&mut ps.iter().map(|s| s.clone().into_string().unwrap()).collect::<Vec<String>>());
                            },
                            Err(e) => {
                                eprintln!("could not list {}", e);
                                app.add_line(format!("could not list"))
                            },
                        }
                    },
                    ParseResult::Malformed(s) => {
                        app.add_line(format!("{}", s));
                    },
                    ParseResult::Exit => {
                        break;
                    },
                    ParseResult::Send(s) =>  {
                        app.add_line(format!("sending {}", s));
                        match mocks.fetch(&(s + ".json")) {
                            Ok(json) => {
                                app.add_lines(&mut json.clone().lines().map(str::to_string).collect::<Vec<String>>());
                                if let Some(ref mut lines) = adapter.send_message(json) {
                                    app.add_lines(lines);
                                }
                            },
                            Err(e) => {
                                app.add_line(format!("could not get message: {}", e));
                            },
                        }
                    }
                }
            }

            // check if there are messages to render
            if let Some(mut lines) = adapter.get_log_line() {
                app.add_lines(&mut lines);
            }
            
            // render app
            app.render();
            ncurses::refresh();
            stdout().flush().unwrap();

            thread::sleep(time::Duration::from_millis(20));
        }
    }
}

impl Drop for App {
    fn drop(&mut self) {
        ncurses::endwin();
    }
}

fn ncurses_ch_to_char(c: i32) -> Option<char> {
    match u32::try_from(c) {
        Ok(c) => char::from_u32(c),
        _ => None,
    }
}
